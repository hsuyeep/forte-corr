/* Functions related to correlating raw data.
 * pep/23Aug12
 */

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <math.h>
#include <sys/time.h>
#include <time.h>
#include "../include/corrops.h"    // Holds datastructures and functions 
                                   // specific to FFT and XMAC.
#include "../include/datalayout.h" // For raw frame layout
#include "../include/memmgmt.h"    // For region layout


/* Initialize the FFTW library for the FFT parameters passed in
 */
int init_fftw (FftType **fftinfo)
{ // NOTE: We create the FftType here, so want a NULL pointer!
  if (*fftinfo != NULL) return -1; 
  int shortcmplxsize = 0;
 
  if ((*fftinfo=(FftType*) calloc (sizeof (FftType), 1)) == NULL)
  { perror ("calloc"); return -1; }

  (*fftinfo)->taps      = 64;
  (*fftinfo)->words2pkt = 0;
  (*fftinfo)->blks2acc  = 0;
  (*fftinfo)->dnu       = 0;

  if(((*fftinfo)->in =(fftwf_complex*) fftwf_malloc 
                   (sizeof (fftwf_complex)* (*fftinfo)->taps))==NULL)
  { perror ("fftw_malloc"); return -1;}

  if(((*fftinfo)->out=(fftwf_complex*) fftwf_malloc 
                   (sizeof (fftwf_complex)* (*fftinfo)->taps))==NULL)
  { perror ("fftw_malloc"); return -1;}
  
  (*fftinfo)->p = fftwf_plan_dft_1d ((*fftinfo)->taps, (*fftinfo)->in, 
                              (*fftinfo)->out, FFTW_FORWARD, FFTW_ESTIMATE);

  // Allocate memory for holding the shortcomplex output of a full set.
  // (All antennas).
  // shortcmplxsize = (*fftinfo)->taps/2 * Samps2Frame/(*fftinfo)->taps * Antennas 
  //                 * 2; // For re/im.
  shortcmplxsize = Samps2Frame * Antennas;

  if (((*fftinfo)->setoutput=(short*) calloc (shortcmplxsize, sizeof(short)))
      == NULL)
  { perror ("calloc"); return -1; }

  return 0;
}

/* De-Initialize the FFTW library for the FFT parameters passed in
 */
int deinit_fftw (FftType *fftinfo)
{ if (fftinfo == NULL) return -1;

  if (fftinfo->in ) fftwf_free (fftinfo->in );
  if (fftinfo->out) fftwf_free (fftinfo->out);
  fftwf_destroy_plan (fftinfo->p);
  if (fftinfo->setoutput) free (fftinfo->setoutput);
  if (fftinfo) free (fftinfo);
  
  return 0;
}

/* Function to shuffle short complex input as generated by fftw_frame into
 * WordVectorTypes, as expected by xmac_set ()
 *  Input format: (short complex, available in fft->setoutput) = 1 set worth.
 *    Each channel is a short complex (real and imag in consecutive addresses).
 *FFT A0|A1 {ts00 A0[ch0,ch1...ch31] A1[ch0,ch1...ch31] 
 *           ts01 A0[ch0,ch1...ch31] A1[ch0,ch1...ch31] 
 *           ... 
 *           ts23 A0[ch0,ch1...ch31] A1[ch0,ch1...ch31]}
 *
 *FFT A2|A3 {ts00 A2[ch0,ch1...ch31] A3[ch0,ch1...ch31] 
 *           ts01 A3[ch0,ch1...ch31] A3[ch0,ch1...ch31] 
 *           ... 
 *           ts23 A2[ch0,ch1...ch31] A3[ch0,ch1...ch31]}
 *   ...
 *
 *FFT A38|A39 {ts00 A38[ch0,ch1...ch31] A39[ch0,ch1...ch31] 
 *             ts01 A38[ch0,ch1...ch31] A39[ch0,ch1...ch31] 
 *           ... 
 *             ts23 A38[ch0,ch1...ch31] A39[ch0,ch1...ch31]}
 *
 * Output format (Organized in WordVectorTypes, finfo->fftout)
 *    4 FFT timeslices of a pair of channels of a single antenna, per 
 *  WordVectorType. Each channel is a short complex.
 * -----------------------------------------------------------------------
 * A0re {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} +
 * A0im {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} |512 
 * A0re {ch0ts04 ch1ts04 ch0ts05 ch1ts05 ch0ts06 ch1ts06 ch0ts07 ch1ts07} |samp
 * A0im {ch0ts04 ch1ts04 ch0ts05 ch1ts05 ch0ts06 ch1ts06 ch0ts07 ch1ts07} +
 *
 * A0re {ch0ts08 ch1ts08 ch0ts09 ch1ts09 ch0ts10 ch1ts10 ch0ts11 ch1ts11}
 * A0im {ch0ts08 ch1ts08 ch0ts09 ch1ts09 ch0ts10 ch1ts10 ch0ts11 ch1ts11} 
 * A0re {ch0ts12 ch1ts12 ch0ts13 ch1ts13 ch0ts14 ch1ts14 ch0ts15 ch1ts15}
 * A0im {ch0ts12 ch1ts12 ch0ts13 ch1ts13 ch0ts14 ch1ts14 ch0ts15 ch1ts15}
 *
 * A0re {ch0ts16 ch1ts16 ch0ts17 ch1ts17 ch0ts18 ch1ts18 ch0ts19 ch1ts19}
 * A0im {ch0ts16 ch1ts16 ch0ts17 ch1ts17 ch0ts18 ch1ts18 ch0ts19 ch1ts19} 
 * A0re {ch0ts20 ch1ts20 ch0ts21 ch1ts21 ch0ts22 ch1ts22 ch0ts23 ch1ts23}
 * A0im {ch0ts20 ch1ts20 ch0ts21 ch1ts21 ch0ts22 ch1ts22 ch0ts23 ch1ts23}
 * -----------------------------------------------------------------------
 * A1re {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} +
 * A1im {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} |512 
 * ...
 *
 * -----------------------------------------------------------------------
 * A39re {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} +
 * A39im {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} |512 
 * -----------------------------------------------------------------------
 */
inline int shuffle_fft_antpair (FftType *fft)
{ if (fft == NULL) return -1;
  int ant = 0, ch = 0, ts = 0, j = 0, m = 0;
  WordVectorType *chgrpant = NULL; 
  short *antpair_ts_spectra = NULL;

  for (ch=0; ch<ChanGroups; ch++)      // Do for every channel group
  { for (ant=0; ant<Frames2Set; ant++) // Do for all antenna pairs
    { chgrpant = fft->fftout + ch*Vectors2Frame*Antennas + 2*ant*Vectors2Frame;

      // Do for all timeslices of first antenna in an ant-pair
      for (ts=0,j=0; j<Vectors2Frame; j++,ts+=4) 
      { for (m=0; m<4; m++)
        { antpair_ts_spectra = 
                  fft->setoutput + (ant*2*Taps*TSlices2Set + (ts+m)*2*Taps);

          // even channel
          chgrpant[j].re[2*m  ] = antpair_ts_spectra[4*ch    ];// re
          chgrpant[j].im[2*m  ] = antpair_ts_spectra[4*ch + 1];// im

          // odd channel
          chgrpant[j].re[2*m+1] = antpair_ts_spectra[4*ch + 2];// re
          chgrpant[j].im[2*m+1] = antpair_ts_spectra[4*ch + 3];// im
        }
      }

      // Do for all timeslices of second antenna in an ant-pair
      chgrpant = fft->fftout + ch*Vectors2Frame*Antennas + (2*ant+1)*Vectors2Frame;
      for (ts=0,j=0; j<Vectors2Frame; j++,ts+=4) 
      { for (m=0; m<4; m++)
        { antpair_ts_spectra = 
              fft->setoutput + (ant*2*Taps*TSlices2Set + (ts+m)*2*Taps + Taps);

          // even channel
          chgrpant[j].re[2*m  ] = antpair_ts_spectra[4*ch    ];// re
          chgrpant[j].im[2*m  ] = antpair_ts_spectra[4*ch + 1];// im 
 
          // odd channel
          chgrpant[j].re[2*m+1] = antpair_ts_spectra[4*ch + 2];// re
          chgrpant[j].im[2*m+1] = antpair_ts_spectra[4*ch + 3];// im 
        }
      }
    }
  }
  
  return 0;
}

/* Function to print the shuffled output as created by fftw_shuffle_antpair ()
 */
int print_shuffle_fft_antpair (FftType *fft, FILE *fp)
{ if (fft == NULL || fp == NULL) return -1;
  int ch=0, ant=0, ts=0, j=0, m=0;
  WordVectorType *vec= NULL;

  for (ch=0; ch<ChanGroups; ch++) 
  { for (ant=0; ant<Antennas; ant++)
    { fprintf (fp, "\n\n# Antenna %2d, chan %2d & %2d\n", ant, 2*ch, 2*ch+1);
      vec = fft->fftout + ch*Antennas*Vectors2Frame + ant*Vectors2Frame;

      for (j=0,ts=0; ts<TSlices2Set; ts+=4,j++)
      { for (m=0; m<4; m++)
        { fprintf (fp, "%2d   %8d %8d    %8d %8d\n", 
                   ts+m, vec[j].re[2*m  ], vec[j].im[2*m], 
                         vec[j].re[2*m+1], vec[j].im[2*m+1]); 
        }
      }
    }
  }

  return 0;
}

/* Function to shuffle short complex input as generated by fftw_frame into
 * WordVectorTypes, as expected by xmac_set ()
 *  Input format: (short complex, available in fft->setoutput) = 1 set worth.
 *    Each channel is a short complex (real and imag in consecutive addresses).
 *FFT ts00    {A0[ch0,ch1...ch31] A1[ch0,ch1...ch31] ... A39[ch0,ch1...ch39]}
 *FFT ts01    {A0[ch0,ch1...ch31] A1[ch0,ch1...ch31] ... A39[ch0,ch1...ch39]}
 *   ...
 *FFT ts23    {A0[ch0,ch1...ch31] A1[ch0,ch1...ch31] ... A39[ch0,ch1...ch39]}
 *
 *  Output format (Organized in WordVectorTypes, finfo->fftout)
 *    4 FFT timeslices of a pair of channels of a single antenna, per 
 *  WordVectorType. Each channel is a short complex.
 * -----------------------------------------------------------------------
 * A0re {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} +
 * A0im {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} |512 
 * A0re {ch0ts04 ch1ts04 ch0ts05 ch1ts05 ch0ts06 ch1ts06 ch0ts07 ch1ts07} |samp
 * A0im {ch0ts04 ch1ts04 ch0ts05 ch1ts05 ch0ts06 ch1ts06 ch0ts07 ch1ts07} +
 *
 * A0re {ch0ts08 ch1ts08 ch0ts09 ch1ts09 ch0ts10 ch1ts10 ch0ts11 ch1ts11}
 * A0im {ch0ts08 ch1ts08 ch0ts09 ch1ts09 ch0ts10 ch1ts10 ch0ts11 ch1ts11} 
 * A0re {ch0ts12 ch1ts12 ch0ts13 ch1ts13 ch0ts14 ch1ts14 ch0ts15 ch1ts15}
 * A0im {ch0ts12 ch1ts12 ch0ts13 ch1ts13 ch0ts14 ch1ts14 ch0ts15 ch1ts15}
 *
 * A0re {ch0ts16 ch1ts16 ch0ts17 ch1ts17 ch0ts18 ch1ts18 ch0ts19 ch1ts19}
 * A0im {ch0ts16 ch1ts16 ch0ts17 ch1ts17 ch0ts18 ch1ts18 ch0ts19 ch1ts19} 
 * A0re {ch0ts20 ch1ts20 ch0ts21 ch1ts21 ch0ts22 ch1ts22 ch0ts23 ch1ts23}
 * A0im {ch0ts20 ch1ts20 ch0ts21 ch1ts21 ch0ts22 ch1ts22 ch0ts23 ch1ts23}
 * -----------------------------------------------------------------------
 * A1re {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} +
 * A1im {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} |512 
 * ...
 *
 * -----------------------------------------------------------------------
 * A39re {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} +
 * A39im {ch0ts00 ch1ts00 ch0ts01 ch1ts01 ch0ts02 ch1ts02 ch0ts03 ch1ts03} |512 
 * -----------------------------------------------------------------------
 */
inline int shuffle_fft (FftType *fft)
{ if (fft == NULL) return -1;
  int i = 0, j = 0, k = 0, m = 0;
  int chans = fft->taps/2;
  int fft_ts_stride =  2 * chans * Antennas; // In units of shorts.
  WordVectorType *chgrpant = NULL; 

  // Create a set of all antennas for a single channel group within k loop.
  for (k=0; k<ChanGroups; k++) 
  { for (i=0; i<Antennas; i++)
    { short *ant_spectra = fft->setoutput + i*2*chans + k*2*Chans2Group; //input
      chgrpant=fft->fftout + k*Vectors2Frame*Antennas + i*Vectors2Frame;//output

      // Fill a channel pair from a frame of data, single antenna.
      for (j=0; j<Vectors2Frame; j++) // 4 fft tslices for a single ant, 1 frame
      { for (m=0; m<4; m++) // 4 FFT timeslices get filled here.
        { // even chan
          chgrpant[j].re[2*m  ] = ant_spectra[ (j*4+m) * fft_ts_stride   ]; 
          chgrpant[j].im[2*m  ] = ant_spectra[ (j*4+m) * fft_ts_stride +1];
          // odd chan
          chgrpant[j].re[2*m+1] = ant_spectra[ (j*4+m) * fft_ts_stride +2]; 
          chgrpant[j].im[2*m+1] = ant_spectra[ (j*4+m) * fft_ts_stride +3];
        }
      }
    }
  }

  return 0;
}


/* Function to plant a known pattern in fft->setoutput to check fftw_shuffle ()
 * A short word filled is a  digit number, with:
 *  MSD -> ts(2digits) Ant(2 digits) chan(2digits) re/im (1digit)<- LSDigit.
 * Generates a single set of data, ie, 24 timeslices, 40 ants, 32 channels.
 */
inline int shuffle_fill_pattern (FftType *fft)
{ if (fft == NULL || fft->setoutput == NULL) return -1;
  int ant = 0, ts = 0, ch = 0, chans = fft->taps/2;
  
  for (ts=0; ts<24; ts++)
  { for (ant=0; ant < Antennas; ant++)
   { for (ch=0; ch<chans; ch++)
     { fft->setoutput[ts*Antennas*chans*2 + ant*chans*2 + 2*ch  ] 
                 = ch + ant*100; // + ts*10000; // real part
                 // = ant;
       fft->setoutput[ts*Antennas*chans*2 + ant*chans*2 + 2*ch+1] 
                 = ch + ant*100; // + ts*10000; // imag part
                 // = ant;
     }
   }
  }
  return 0;
}

/* retrieve_pair for pair FFT implementation. Extracts out the FFT of each
 * component of the pair, converts to short, places output in packout, which is
 * assumed to be appropriately positioned for the passed FFT timeslice.
 */

inline int retrieve_pair_fft (fftwf_complex *out, short *packout, 
                                      int chans)
{ if (out == NULL || packout == NULL) return -1;
  int i = 0, taps = 2*chans;
  short a0r = 0, a0i = 0, a1r = 0, a1i = 0;

  // Pack DC and chan N/2 together as 0th channel of output.
  packout [0] = out [0][0]; 
  packout [1] = out [chans][0];        // For a0
  packout [2*chans  ] = out[0][1]; 
  packout [2*chans+1] = out[chans][1]; // For a1

  for (i=1; i<chans; i++)
  { // No division by 2, to match CRS's FFT output.
    a0r = (short)(out [i][0] + out [taps-i][0]); 
    a0i = (short)(out [i][1] - out [taps-i][1]);

    a1r = (short)(out [i][1] + out [taps-i][1]);
    a1i = (short)(out [i][0] - out [taps-i][0]);
  
    packout [2*i  ] = a0r; 
    packout [2*i+1] = a0i;
    packout [2*chans + 2*i    ] = a1r; 
    packout [2*chans + 2*i + 1] = a1i;
  }

  return 0;
}

/* Carries out an FFT within a single frame of data, with short complex
 * output being written to out.
 */
inline int fftw_frame (unsigned char *framedat, FftType *finfo, short *out)
{ if (framedat == NULL || out == NULL) return -1;
  int i = 0, j = 0, taps = finfo->taps, chans = taps/2;

  for (i=0; i<Samps2Frame/taps; i++)
  { // Write nibble packed data into float complex array
    // NOTE: Carrying out pair FFT; both real and imaginary are separate ants.
    for (j=0; j<taps; j++)
    { finfo->in[j][0] = ( framedat[i*taps + j]&15);
      finfo->in[j][1] = ((framedat[i*taps + j]>>4)&15);
    }

    fftwf_execute (finfo->p);

    // Retrieve pair, write float complex data as short complex, for a
    // pair of antennae.
    // Output data format is detailed in datalayout.h
    retrieve_pair_fft (finfo->out, out + 2*i*Taps, chans);

#if 0
    // Debug: Write out raw data, complex output, retrieve pair output to file.
    fprintf (stderr, "# out: %p, Timeslice: %2d.\n", out, i);
    for (j=0; j<chans; j++)
     fprintf (stderr, "0x%02x %8.3f %8.3f %8.3f %8.3f   %8d %8d %8d %8d\n", 
              framedat [i*taps+j],
              finfo->in [j][0], finfo->in [j][1],
              finfo->out[j][0], finfo->out[j][1],
              out [2*i*Taps + 2*j], out [2*i*Taps + 2*j+1],
              out [2*i*Taps + 2*chans + 2*j], out [2*i*Taps + 2*chans + 2*j+1]);

    for (j=chans; j<taps; j++)
     fprintf (stderr, "0x%02x %8.3f %8.3f %8.3f %8.3f\n", framedat [i*taps+j],
              finfo->in [j][0], finfo->in [j][1],
              finfo->out[j][0], finfo->out[j][1]);
    fprintf (stderr, "\n\n");
#endif
  }

  return 0;
}

/* Carries out FFT of the single specified set.
 * Since the set has all antennas, spectra of all antennas is 
 * estimated. 
 * The stripped metadata is available in a separate memory area. 
 * NOTE: The output is generated as short complex words, even though the FFT
 * is computed on floating point data.
 * NOTE: 1 frame (Samps2Frame Bytes) contains a single pair of antennas, 
 * function operates on a set of frames corresponding to all antennas, same
 * timestamp. nantpairs is the number of frames in a set, as each frame is 
 * an antenna pair.
 */
inline int fftw_set_fft(unsigned char *framedat, int nantpairs, FftType *fft)
{ if (framedat == NULL || fft == NULL) return -1;
  int i = 0, j = 0, k = 0;

  // Offset after which to write FFT output, in WordVectorType units.
  // int framefft_off = (fft->taps/2 * Samps2Frame/fft->taps * 2);

  for (i=0; i<nantpairs; i++) // FFT of a single set. NOTE: Can use strided fft
  { // FFT on a single frame, i.e, 24 Timeslices of a pair of antennas.
    fftw_frame (framedat + i*Samps2Frame, fft, 
          // fft->setoutput + i * Vectors2Frame * ChanGroups * Chans2Group * 2);
            fft->setoutput + i * TSlices2Set * 2*Taps);
  }

#if 0
  for (i=0; i<Antennas/2; i++)
  { for (k=0; k<TSlices2Set; k++)
    { fprintf (stderr, "# Antenna %2d & %2d, ts %d.\n", 2*i, 2*i+1, k);
      for (j=0; j<Taps/2; j++)
        fprintf (stderr, "%8d %8d   %8d %8d\n", 
                fft->setoutput[i*TSlices2Set*2*Taps + k*2*Taps + 2*j], 
                fft->setoutput[i*TSlices2Set*2*Taps + k*2*Taps + 2*j+1],
                fft->setoutput[i*TSlices2Set*2*Taps + k*2*Taps + Taps + 2*j], 
                fft->setoutput[i*TSlices2Set*2*Taps + k*2*Taps + Taps + 2*j+1]);
      fprintf (stderr, "\n\n");
    }
  }
#endif 

  // All antennas' spectra with consecutive channels per antenna is available 
  // in fft->fftout. We reorganize them for XMAC, storing the result in
  // fftout, ready for XMAC.
  shuffle_fft_antpair (fft);
  // fftw_print_shuffle_antpair (fft, stderr);
  
  return 0;
} 

/* Function to dump WordVectorType for a set to file, for debug
 */
int dump_setoutput_file (FftType *fft, FILE *fp)
{ if (fft == NULL || fp == NULL) return -1;
  int bytes2write = 
      sizeof (WordVectorType) * Antennas * Vectors2Frame * ChanGroups;

  if (fwrite (fft->fftout, 1, bytes2write, fp) < bytes2write)
  { perror ("fwrite"); return -1; }

  return 0;
}

/* Function to print out the generated FFT to specified file.
 *  Prints the contents of finfo->setoutput.
 */
int print_setoutput_file (FftType *finfo, FILE *fp)
{ if (finfo == NULL || fp == NULL) return -1;
  int i = 0, j = 0, k = 0;

  for (i=0; i<TSlices2Set; i++)
  { fprintf (fp, "---------------------------------------------------------\n");
    for (j=0; j<Antennas; j++)
    { fprintf (fp, "\n\n# Timeslice: %2d, Antenna: %2d\n", i, j);
      for (k=0; k<Taps/2; k++)
      { fprintf (fp, "%8d %8d\n", 
                  finfo->setoutput[i*Antennas*Taps + j*Taps + 2*k], 
                  finfo->setoutput[i*Antennas*Taps + j*Taps + 2*k+1]);
      }
    }
  }

  return 0;
}

/* Function to print out the generated FFT to specified file.
 *  Prints the contents of finfo->fftout.
 */
int print_fftout_file (FftType *finfo, FILE *fp)
{ if (fp == NULL || finfo == NULL) return -1;
  int i = 0, j = 0, k =0, m =0;
  WordVectorType *word = finfo->fftout;
  
  // Printing the contents of every WordVectorType
  for (m=0; m<ChanGroups; m++)
  { fprintf (fp, "# Chan group %02d.\n", m);
    for (j=0; j<Antennas; j++)
    { word = finfo->fftout + m*Vectors2Frame*Antennas + j*Vectors2Frame;
      for (i=0; i<Vectors2Frame; i++)
      { fprintf (fp, "A%02dc%02dr: ", j, m);
        for (k=0; k<8; k++) 
          fprintf (fp, "%6d ", word[i].re[k]); 
        fprintf (fp,"\n");
  
        fprintf (fp, "A%02dc%02di: ", j, m);
        for (k=0; k<8; k++) 
          fprintf (fp, "%6d ", word[i].im[k]); 
        fprintf (fp,"\n");
      }
      fprintf (fp, "-----------------------------------------------------\n");
    }
  }
  return 0;
}

/* Function to fill the input to xmac (ie, fft output) with a known pattern for
 * debugging xmac implementations. The fft output is expected to be short ints, 
 * with a layout as described in fftw_shuffle_antpair ().
 */
inline int xmac_fill_pattern (FftType *finfo)
{ if (finfo == NULL) return -1;
  int i = 0, j = 0, k = 0, m = 0;
  WordVectorType *ant = NULL;
  // int antoff = sizeof (WordVectorType)*Vectors2Frame;

  for (i=0; i<Taps/(2*Chans2Group); i++)
  { for (j=0; j<Antennas; j++)
    { ant = finfo->fftout + (i*Antennas+j)*Vectors2Frame;
      for (k=0; k<Vectors2Frame; k++) // 4 timeslices/2ch, per wordvector
      { for (m=0; m<4; m++)
        { ant[k].re[2*m    ] = j+m; ant[k].im[2*m    ] = j+m; // Even channel
          ant[k].re[2*m + 1] = j+m; ant[k].im[2*m + 1] = j+m; // Odd channel
         
          // ant[k].re[2*m    ] = m; ant[k].im[2*m    ] = m; // Even channel
          // ant[k].re[2*m + 1] = m; ant[k].im[2*m + 1] = m; // Odd channel
          
          // ant[k].re[2*m    ] = m; ant[k].im[2*m    ] = m+1; // Even channel
          // ant[k].re[2*m + 1] = m+2; ant[k].im[2*m + 1] = m+3; // Odd channel
        }
      }
    }
  }
  
  return 0;
}

/* Function to carry out a correlation between all antennas, all channels.
 * The input to this routine is the output after FFT, whose data layout is 
 * specified in fftw_shuffle. The generated output is the correlation integrated
 * over the entire set (i.e., 24 timeslices). The correlations are as stored as
 * integer complex, with a channelgroup held in consecutive addresses:
 *
 * -----------------------------------------------------------------------
 * bline0 |ch0ts00-23 ch1ts00-23|ch2ts00-23 ch3ts00-23| ... |ch31ts00-23
 * bline1 |ch0ts00-23 ch1ts00-23|ch2ts00-23 ch3ts00-23| ... |ch31ts00-23
 *   ... 
 * bline(N(N-1)/2) ch0ts00-23 ch1ts00-23 ch2ts00-23 ch3ts00-23 ... ch31ts00-23
 * -----------------------------------------------------------------------
 */
int xmac_set (FftType *finfo, CorrOutType *corr)
{ if (finfo == NULL || corr == NULL) return -1;
  int a0 = 0, a1 = 0, bline = 0, m=0, k=0, chan = 0, *corrout = NULL;
  WordVectorType *ant0 = NULL, *ant1 = NULL;
  // int chansize = 2*sizeof(int)*Chans2Group, blinesize = Taps*Chans2Group; //ints

  for (chan=0; chan<ChanGroups; chan++)
  { for (bline=0,a0=0; a0<Antennas; a0++)
    { for (a1=a0+1; a1<Antennas; a1++, bline++)
      { ant0 = finfo->fftout + chan*Vectors2Frame*Antennas + a0*Vectors2Frame; 
        ant1 = finfo->fftout + chan*Vectors2Frame*Antennas + a1*Vectors2Frame;
        corrout = corr->corr + bline*Taps + chan*Chans2Group*2;
        bzero (corrout, Chans2Group*2*sizeof(int));

        for (k=0; k<TSlices2Set/4; k++) // 4 timeslices per wordvector
        { for (m=0; m<4; m++)           // 2 channels per wordvector
          { // Real part
            corrout[0] += ant0[k].re[2*m  ] * ant1[k].re[2*m  ] // ch0, re
                        + ant0[k].im[2*m  ] * ant1[k].im[2*m  ];

            corrout[2] += ant0[k].re[2*m+1] * ant1[k].re[2*m+1] // ch1, re
                        + ant0[k].im[2*m+1] * ant1[k].im[2*m+1];
            // Imag part
            corrout[1] += ant0[k].im[2*m  ] * ant1[k].re[2*m  ] // ch0, im
                        - ant0[k].re[2*m  ] * ant1[k].im[2*m  ];

            corrout[3] += ant0[k].im[2*m+1] * ant1[k].re[2*m+1] // ch1, im
                        - ant0[k].re[2*m+1] * ant1[k].im[2*m+1];
          }
        }
      }
    }
  }

  return 0;
}

/* Function to print the real/imag. components of correlated frames.
 * Assuming data is laid out in integer re/im format, as described in 
 * xmac_set().
 */
int print_xmac_reim_file (CorrOutType *corr, FILE *fp)
{ if (corr == NULL || fp == NULL) return -1;
  int i = 0, j = 0, blinesize = Taps;

  for (i=0; i<Blines; i++)
  { fprintf (fp, "# Baseline %d\n", i);
    for (j=0; j<Taps/2; j++)
      fprintf (fp, "%8d %8d\n", corr->corr[i*blinesize + 2*j    ], 
                                corr->corr[i*blinesize + 2*j + 1]);
    fprintf (fp, "\n\n");
  }

  return 0;
}

/* Function to print the amplitudes and phases of correlated frames.
 * Assuming data is laid out in integer re/im format, as described in 
 * xmac_set().
 */
int print_xmac_ampph_file (CorrOutType *corr, FILE *fp, int log)
{ if (corr == NULL || fp == NULL) return -1;
  int i = 0, j = 0, blinesize = Taps;
  float re = 0, im = 0;

  if (log == 1)
  { for (i=0; i<Blines; i++)
    { fprintf (fp, "# Baseline %d\n", i);
      for (j=0; j<Taps/2; j++)
      { re = corr->corr[i*blinesize + 2*j    ]; 
        im = corr->corr[i*blinesize + 2*j + 1];
        fprintf (fp, "%8.3f %8.3f\n", log10 (re*re + im*im), atan2 (im,re));
      }
      fprintf (fp, "\n\n");
    }
  }
  else
  { for (i=0; i<Blines; i++)
    { fprintf (fp, "# Baseline %d\n", i);
      for (j=0; j<Taps/2; j++)
      { re = corr->corr[i*blinesize + 2*j    ]; 
        im = corr->corr[i*blinesize + 2*j + 1];
        fprintf (fp, "%8f %8f\n", (float) (re*re + im*im), atan2 (im,re));
      }
      fprintf (fp, "\n\n");
    }
  }

  return 0;
}

/* Function to dump binary correlated frames to disk
 * (Currently without any metadata)
 */
int dump_xmac_reim_file (CorrOutType *corr, FILE *fp) 
{ if (corr == NULL || fp == NULL) return -1;
  
  int bytes2write = 
      sizeof (int) * Blines * Taps;

  if (fwrite (corr->corr, 1, bytes2write, fp) < bytes2write)
  { perror ("fwrite"); return -1; }

  return 0;
}

int gen_bin_fname (char *fname, int len)
{ if (fname == 0 || len < 0) return -1;
  char months[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug"
                      "Sep", "Oct", "Nov", "Dec"};
  struct timeval tv;
  struct tm *t = NULL;
  gettimeofday (&tv, NULL);
  t = localtime (&tv.tv_sec);
  sprintf (fname, "%02d%02d%02d_%02d%s%02d.bin", t->tm_hour, t->tm_min, 
           t->tm_sec, t->tm_mday, months[t->tm_mon], t->tm_year%100);

  return 0;
}
